{% extends ':admin:base_with_header.html.twig' %}

{% block content %}
    <h2>Générer une veille de l'AFUP</h2>

    <style>
        #preview-techletter{
            width: 50%;
            float:left;
            border: 1px grey solid;
            box-sizing: content-box;
        }
		form#link-editor {
			width: 600px !important;
			margin-left: calc(50% + 1em);
			padding: 1em;
			box-sizing: content-box;
			position: fixed;
			top: 50%;
			left:0;
			transform: translate(0, -50%);
			background: #b4cbde;
		}
		form#link-editor.hidden{
			display: none;
		}

		form#link-editor label {
			display: inline-block;
			width: 15%;
		}
		form#link-editor input, form#link-editor textarea{
			width: 85%;
			border: 1px grey solid;
		}
		form#link-editor input[type=submit], form#link-editor input[type=reset], form#link-editor button{
			width: 33%;
			color: #000;
			background-color: #fff;
			border: 1px solid #fff;
			margin: .1em 0;
		}
		form#link-editor input[type=submit]{
			color: #fff;
			background-color: #ed0678;
			border: 1px solid #ed0678;
		}
		form #close{
			display: block;
			float: right;
		}
    </style>
	<link rel="stylesheet" href="{{ asset('assets/techletter/notyf.min.css') }}" />
	<script src="{{ asset('assets/techletter/notyf.min.js') }}"></script>

    <iframe src="" id="preview-techletter" name="preview-techletter" frameborder="0"></iframe>

	<form id="link-editor" class="hidden">
		<a href="#" id="close">X</a>
		<fieldset id="update-link">

		</fieldset>
		<button id="refresh" title="Ecraser la saisie actuelle par les informations récupérées depuis l'url indiquée">
			Actualiser depuis l'url saisie
		</button>
		<button id="delete">Supprimer ce lien</button>
		<input type="reset" value="Fermer" />
		<input type="submit" value="Sauvegarder et mettre à jour" />
	</form>

	<form method="post" action="{{ url('preview') }}" target="preview-techletter" id="form-update">
		<input type="hidden" name="techletterId" value="{{ sending.id }}" />
		<input type="hidden" name="_csrf_token" value="{{ csrf_token('techletterPreview') }}" />
		<input name="techletter" id="textarea" type="hidden" value="" />
	</form>

	<form method="post" class="afup--form">
		<fieldset>
			<legend>Synchronisation vers mailchimp</legend>

			<input
					type="submit"
					name="sendToMailchimp"
					value="Verrouiller et envoyer à mailchimp"
					onclick="return confirm('Etes-vous sur que cette NL est prete ?');"
			/>

			<input type="hidden" name="_csrf_token" value="{{ csrf_token('sendToMailchimp') }}" />
		</fieldset>
	</form>

    <script>
        (function(w, d){
        	'use strict';

        	let overlayElement = null;

        	let createElement = function (textContent)
            {
            	overlayElement = d.createElement('div');
            	overlayElement.setAttribute('id', 'overlayOnIframe');

				let text = d.createTextNode(textContent);
				overlayElement.appendChild(text);

            	d.body.appendChild(overlayElement);

            	return overlayElement;
            };

			w.IframeOverlay = {};
			IframeOverlay = function(iframe, clickCallback, text) {
				this.iframe = iframe;
				this.clickCallback = clickCallback;
				this.text = text;
			};

			IframeOverlay.prototype = {
				iframe: null,
				clickCallback: null,
				overlayColor: 'rgba(120, 120, 120, .8)',
				text: null,

				/**
                 * Creates an overlay in the parent window.
                 * Values x and y are referring to the position of the overlay IN the iframe
                 *
				 * @param {String} reference is given to the callback as the first parameter
				 * @param {Int} x
				 * @param {Int} y
				 * @param {Int} width
				 * @param {Int} height
				 */
				show: function(reference, x, y, width, height) {
					this.remove();

					let iframeParams = this.iframe.getBoundingClientRect();
                    createElement(this.text);

                    x += iframeParams.left;
                    y += iframeParams.top;

                    overlayElement.setAttribute(
                    	'style',
                        'position: fixed; display: block; z-index: 1000; ' +
                        'top: ' + y + 'px; left: ' + x + 'px;' +
                        'cursor: pointer;' +
                        'width: ' + width + 'px; height: ' + height + 'px; ' +
                        'background-color: ' + this.overlayColor + ';' +
						'font-size: 20px; color:white; text-align:center;'
                    );

                    overlayElement.addEventListener('click', event => { this.clickCallback(reference, event); });
					overlayElement.addEventListener('mouseleave', this.remove);
				},
				remove: function() {
					if (overlayElement !== null) {
						overlayElement.remove();
						overlayElement = null;
                    }
				}
			};
        })(window, document);

		(function(w, d) {
			'use strict';

			let getModelForType = (type) => {
				let model = editableElements.find(item => {
					return item.type === type;
				});
				if (typeof model !== "undefined") {
					return model.model;
				}
				return false; // or throw error ?
			};

			/**
			 *
			 * @param oldLink
			 * @param newData if null, will remove the entry
			 * @returns {boolean}
			 */
			let updateDataForLink = function (oldLink, newData) {
				if (techletter.firstNews && techletter.firstNews.url === oldLink) {
					if (newData === null) {
						techletter.firstNews = techletter.secondNews;
						techletter.secondNews = null;
					} else {
						techletter.firstNews = newData;
					}
					return true;
				}
				if (techletter.secondNews && techletter.secondNews.url === oldLink) {
					techletter.secondNews = newData;
					return true;
				}

				for (let index in techletter.articles) {
					if (techletter.articles[index].url === oldLink) {
						if (newData === null) {
							techletter.articles.splice(index, 1);
						} else {
							techletter.articles[index] = newData;
						}
						return true;
					}
				}

				for (let index in techletter.projects) {
					if (techletter.projects[index].url === oldLink) {
						if (newData === null) {
							techletter.projects.splice(index, 1);
						} else {
							techletter.projects[index] = newData;
						}
						return true;
					}
				}

				return false;
			};

			let getDataForLink = function (link) {
				if (techletter.firstNews && techletter.firstNews.url === link) {
					return {model: "news", data: techletter.firstNews};
				}
				if (techletter.secondNews && techletter.secondNews.url === link) {
					return {model: "news", data: techletter.secondNews};
				}
				let article = techletter.articles.find(item => {
					if (item.url === link) {
						return true;
					}
				});
				if (typeof article !== "undefined") {
					return {model: "articles", data: article};
				}
				let project = techletter.projects.find(item => {
					if (item.url === link) {
						return true;
					}
				});
				if (project !== "undefined") {
					return {model: "projects", data: project};
				}
				return false; // or throw error ?
			};


			w.LinkEditor = {};
			LinkEditor = function (form) {
				this.form = form;
				this.fieldset = form.querySelector('fieldset');

				// Add Listener on submit for this form, get new data, resolve promise
				this.form.addEventListener('submit', this.handleSubmit.bind(this));
				this.form.addEventListener('reset', this.handleReset.bind(this));
				this.form.querySelector('button#refresh').addEventListener('click', this.handleRefresh.bind(this));
				this.form.querySelector('button#delete').addEventListener('click', this.handleDelete.bind(this));
				this.form.querySelector('#close').addEventListener('click', this.handleReset.bind(this));
			};

			LinkEditor.prototype = {
				form: null,
				fieldset: null,
				resolve: null,
				reject: null,

				/**
				 *
				 * @param model
				 * @param data if null, we will create a blank form
				 */
				createForm: function (model, data) {
					// Remove all children of the fieldset
					while (this.fieldset.firstChild) {
						this.fieldset.removeChild(this.fieldset.firstChild);
					}

					if (data !== null) {
						this.fieldset.dataset.link = data.url;
					}

					Object.keys(model).forEach((key, index) => {
						let label = d.createElement('label');
						let text = d.createTextNode(
							key
								.replace(/([A-Z])/g, str => {return ' ' + str.toLowerCase();})
								.replace(/^./, str => {return str.toUpperCase();})
						);
						label.appendChild(text);
						label.setAttribute('for', `input-${key}`);

						let input = d.createElement(model[key].inputType);
						input.setAttribute('id', `input-${key}`);
						input.dataset.key = key;

						if (data !== null) {
							let value = data[key];
							input.value = value;
						}

						Object.keys(model[key]).forEach((inputOption, index) => {
							input[inputOption] = model[key][inputOption];
						});

						let div = d.createElement('div');
						div.appendChild(label);
						div.appendChild(input);

						this.fieldset.appendChild(div);
					});
				},

				updateLink: function (link) {
					// @todo add "Close" X button
					return new Promise((resolve, reject) => {
						this.resolve = resolve;
						this.reject = reject;

						// Create fields for the data
						let data = getDataForLink(link);
						let model = getModelForType(data.model);
						data = data.data; //@todo do better

						this.fieldset.dataset.type = data.model;

						this.createForm(model, data);
						this.form.classList.remove('hidden');
					});
				},

				addLink: function (type) {
					return new Promise((resolve, reject) => {
						this.resolve = resolve;
						this.reject = reject;


						// Create fields for the data
						let model = getModelForType(type);

						this.createForm(model, null);
						this.form.classList.remove('hidden');
						this.fieldset.dataset.type = type;
						delete this.fieldset.dataset.link;
					});
				},

				handleSubmit: function(event) {
					event.preventDefault();
					let data = [].reduce.call(this.form.elements, (data, element) => {
						if ("key" in element.dataset) {
							data[element.dataset.key] = element.value;
						}
						return data;
					}, {});


					if ("link" in this.fieldset.dataset) {
						updateDataForLink(this.fieldset.dataset.link, data);
					} else {
						if (this.fieldset.dataset.type === "news") {
							if (techletter.firstNews === null) {
								techletter.firstNews = data;
							} else {
								techletter.secondNews = data;
							}
						} else {
							techletter[this.fieldset.dataset.type].push(data);
						}
						this.resolve(data);
						this.form.classList.add('hidden');
						this.form.reset();
						this.updateLink(data.url);
					}

					updatePreview();

					// @todo check how to reject
				},

				handleReset: function (event) {
					event.preventDefault();
					this.form.classList.add('hidden');
					this.resolve(techletter); // Data has been updated so we can resolve the promise
				},

				handleDelete: function (event) {
					event.preventDefault();
					if ("link" in this.fieldset.dataset) {
						updateDataForLink(this.fieldset.dataset.link, null);
					}
					updatePreview();
					this.form.classList.add('hidden');
					this.resolve(techletter); // Data has been updated so we can resolve the promise
				},

				handleRefresh: function (event) {
					event.preventDefault();
					this.lock();

					fetch ('{{ url('retrieve') }}', {
						method: 'POST',
						credentials: 'same-origin',
						headers: {
							'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
						},
						body: 'url=' + encodeURIComponent(this.fieldset.querySelector('#input-url').value)
					})
						.then((response) => response.json())
						.then(json => {
							Object.keys(json).forEach(key => {
								let input = this.form.querySelector(`#input-${key}`);
								if (input !== null) {
									input.value = json[key];
								}
							});
							// @todo move to an event
							notyf.confirm('Mise à jour du lien effectuée');
							this.unlock();
						})
						.catch(error => {
							// @todo move to an event
							notyf.error('Erreur lors de la mise à jour: ' + error);
							this.unlock();
						})
					;
				},

				lock: function () {
					this.fieldset.disabled = "disabled";
				},

				unlock: function () {
					this.fieldset.disabled = "";
				}
			};
		})(window, document);

		(function(w, d) {
			'use strict';

        	let iframeOverlay, iframePlusOverlay;

        	let form = document.querySelector('#form-update');
			w.techletter = {{ tech_letter|json_encode|raw }};

			/**
			 * @todo should not be global, we should use events
			 * @type {Notyf}
			 */
			w.notyf = new Notyf();

			let linkEditor = new LinkEditor(document.querySelector('#link-editor'));

        	w.updatePreview = function ()
			{
				// @todo add overlay when iframe is loading
				form.querySelector('input[name=techletter],textarea[name=techletter]').value = JSON.stringify(techletter);
				form.submit();
			};

        	// Make sure the preview is loaded when loading the page
        	updatePreview();

            w.editableElements = [
            	{
            		type: "news",
					container: '#templateNews',
					selector: 'li',
					maxItems: 2,
					newItemType: 'li',
					model: {
						url: {inputType: "input", type: "url"},
						title: {inputType: "input", type: "text"},
						date: {inputType: "input", type: "date"}
					}
				},
                {
                	type: "articles",
					container: '#templateArticles',
					selector: 'div.template--article',
					maxItems: 10,
					newItemType: 'div',
					model: {
                		url: {inputType: "input", type: "url"},
						title: {inputType: "input", type: "text"},
						host: {inputType: "input", type: "text"},
						readingTime: {inputType: "input", type: "number", min: 1, max: 100, step: 1},
						excerpt: {inputType: "textarea", rows: 10}
					}
				},
                {
                	type: "projects",
					container: '#templateProjects',
					selector: 'li',
					maxItems: 5,
					newItemType: 'div',
					model: {
						url: {inputType: "input", type: "url"},
						name: {inputType: "input", type: "text"},
						description: {inputType: "input", type: "text"}
					}
                }
            ];

        	let onEditableElement = function(event)
            {
            	let elementPosition = event.toElement.getBoundingClientRect();
            	iframeOverlay.show(
            		event.toElement.dataset.url,
            		elementPosition.x,
					elementPosition.y,
					elementPosition.width,
					elementPosition.height
				);
            };

        	let onPlusElement = function(event)
			{
				let elementPosition = event.toElement.getBoundingClientRect();
				iframePlusOverlay.show(
					event.toElement.dataset.type,
					elementPosition.x,
					elementPosition.y,
					elementPosition.width,
					elementPosition.height
				);
			};

        	let declareListeners = function(iframeDocument)
            {
				editableElements.forEach(item => {
                	let items = iframeDocument.querySelectorAll(item.container + ' ' + item.selector);

                	if (items.length < item.maxItems) {
                		// Add "new item" node
						let plusElement = iframeDocument.createElement(item.newItemType);
						plusElement.setAttribute(
							'style',
							'text-align:center; font-size: 20px; font-weight:bold; color: black; list-style-type:none;'
						);
						plusElement.dataset.type = item.type;

						let text = iframeDocument.createTextNode('+');
						plusElement.appendChild(text);

						iframeDocument.querySelector(item.container).appendChild(plusElement);
						plusElement.addEventListener('mouseenter', onPlusElement);
					}
                    items.forEach(element => {
                    	element.addEventListener('mouseenter', onEditableElement);
                    });
                });
				iframeOverlay = new w.IframeOverlay(d.getElementById('preview-techletter'), (reference, event) => {
					console.log('click', reference);

					linkEditor
						.updateLink(reference)
						.then(newdata => {
							notyf.confirm('Mise à jour en cours');
							updatePreview();
						})
						.catch(reason => {
							notyf.alert('Erreur lors de la mise à jour des données : ' + reason);
							console.log('error in promise', reason);
						});
					;
				}, 'Editer');
				iframePlusOverlay = new w.IframeOverlay(d.getElementById('preview-techletter'), (reference, event) => {
					console.log('click plus', reference);

					linkEditor
						.addLink(reference)
						.then(newdata => {
							notyf.confirm('Mise à jour en cours');
							updatePreview();
						})
						.catch(reason => {
							notyf.alert('Erreur lors de la mise à jour des données : ' + reason);
							console.log('error in promise', reason);
						})
					;

				}, 'Ajouter');
			};

			let onPreviewLoaded = function(event)
			{
				this.style.height =	this.contentWindow.document.body.offsetHeight + 'px';
				declareListeners(this.contentWindow.document);
				this.style.height =	this.contentWindow.document.body.offsetHeight + 'px';
			};

        	d.getElementById('preview-techletter').onload = onPreviewLoaded;

        })(window, document);

    </script>

{% endblock %}
